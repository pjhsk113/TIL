# [이펙티브 자바] Item68 - 일반적으로 통용되는 명명 규칙을 따르라

자바 플랫폼은 명명 규칙이 잘 정립되어 있으며, 대부분 자바 언어 명세(JLS)에 기술되어 있다. 자바의 명명 규칙은 크게 철자와 문법 두 범주로 나뉜다.

# 1. 자바의 명명 규칙 - 철자

철자 규칙은 패키지, 클래스, 인터페이스, 메서드, 필드, 타입 변수의 이름 등을 다룬다. 이 규칙을 어긴 API는 사용하기 어려우며 유지보수하기도 어렵다. 또한, 코드를 읽기 번거로워지고 다른 뜻으로도 오해할 수 있으므로 반드시 따른느 것이 좋다.

## 패키지, 모듈

1. (.)으로 구분하여 계층적으로 짓는다.
2. 소문자 알파벳으로 구성되며, 드물게 숫자가 들어가기도 한다.
3. 바깥에서도 사용하는 패키지라면 도메인의 역순으로 구성한다.
4. 각 요소는 8자 이하의 짧은 단어를 사용한다.
5. util 처럼 의미가 통하는 약어를 사용하는 것도 좋다.
6. 많은 기능을 담고 있는 경우, 계층을 나눠 하위 패키지로 많은 요소를 구성해도 좋다.

```java
// 예시
com.google.code.gson
org.projectlombok.lombok
```

## 클래스, 인터페이스, 열거 타입, 애너테이션

1. 하나 이상의 단어로 이루어지며, 각 단어는 대문자로 시작한다.
2. 널리 통용되는 max나 min과 같은 줄임말을 제외하고 단어를 줄여쓰지 말자.
3. 약어의 경우 첫 글자만 대문자로 하는 쪽이 훨씬 많다.

```java
//예시
List
HashMap

// 약어의 경우 첫 글자만 대문자로!
HttpUrl
```

## 메서드, 필드

첫 글자를 소문자로 쓴다는 것을 제외하고 클래스와 동일하다. 만약 첫 단어가 약어라면 전체가 소문자여야 한다.

```java
//예시
remove()
removeAll()
ensureCapacity()

// 첫 단어가 약어라면 전체가 소문자여야 한다.
URL -> uRL(x) / url(o)
```

## 상수 필드

1. 구성하는 모든 단어를 대문자로 구성한다.
2. 단어 사이는 밑줄(_)로 구분한다.

```java
// 예시
Integer.MAX_VALUE
Math.PI
VALUES
NEGATIVE_INFINITY
```

## 지역변수

변수가 사용되는 문맥에서 유추가 가능하기 떄문에 약어를 사용해도 좋다. 이외에는 다른 멤버와 비슷한 명명 규칙을 가진다.

```java
// 예시
i;
denom;
houseNum;
cnt;
```

## 타입 매개변수

타입 매개변수는 대부분 다섯 가지 한 문자로 표현한다.

- 임의의 타입 - T
- 컬렉션 원소 타입 - E
- Map의 키와 값 타입 - K, V
- 예외 타입 - X
- 메서드 반환 타입 - R

그 외에 임의 타입 시퀀스 - T, U, V 혹은 T1, T2, T3

# 2. 자바의 명명 규칙 - 문법

문법 규칙은 철자 규칙과 비교해 더 유연하고 다양하다. 

## 객체를 생성할 수 있는 클래스, 열거 타입

단수 명사 또는 명사구를 사용한다.

```java
// 예시
Thread
PriorityQueue
ChessPiece
```

## 객체를 생성할 수 없는 클래스

복수형 명사를 사용한다.

```java
// 예시
Collections
Collectors
```

## 인터페이스

클래스의 규칙을 따르거나 혹은 ~able, ~ible로 끝나는 형용사로 짓는다.

```java
// 예시
Comparator
Collection

// 혹은 ~able, ~ible
Runnable
Iterable
Closeable
Accessible
```

## 애너테이션

지배적인 규칙은 없다. 명사, 동사, 전치사, 형용사 모두 두루 쓰인다. 잘 전달되는 의미로 지으면 된다.

```java
// 예시
@BindingAnnotation
@Inject
@ImplementedBy
@Singleton
```

## 메서드

- 어떤 동작을 수행하는 메서드의 이름은 동사나 동사구로 짓는다.
- boolean을 반환하는 메서드는 is 혹은 has로 시작하고 기능을 나타내는 아무 단어나 구로 끝나도록 짓는다.
- 해당 인스턴스의 속성을 반환하는 메서드라면 명사, 명사구 혹은 get으로 시작하는 동사구로 짓는다.
- 객체 타입을 바꿔, 다른 타입을 반환하는 메서드라면 **toType** 형태로 짓는다.
- 객체의 내용을 다른 뷰로 보여주는 메서드는 **asType** 형태로 짓는다.
- 객체의 값을 기본 타입 값으로 반환하는 메서드는 **typeValue** 형태로 짓는다.

```java
// 예시
append()
drawImage()

// boolean을 반환하는 경우
isDigit()
isProbablePrime()
isEmpty()
hasSliblings()

// 인스턴스를 반환하는 경우
size()
hasCode()
getTime()

// 객체 타입을 바꿔, 다른 타입을 반환하는 경우
toString()
toArray()

// 객체의 내용을 다른 뷰로 보여주는 경우
asList()

// 객체의 값을 기본 타입 값으로 반환하는 경우
intValue()
```

get으로 시작하는 형태는 명사, 명사구 보다 가독성이 떨어진다.

다만, get은 자바빈즈에 명세에 뿌리를 두고 있어 최근 도구 중에도 이 명명 규칙을 따르는 경우가 많다. 따라서 이런 도구와 어우러지는 코드를 작성한다면 get 명명 규칙을 따라도 상관없다.

## 정적 팩터리

정적 팩터리의 이름은 다양하지만 일반적으로 **from, of, valueOf, instance, getInstance, newInstance, getType, newType** 등을 흔히 사용한다.

## 필드

API를 잘 설계했다면 직접 노출될 일이 거의 없기 때문에 덜 중요하다. 그래도 알아두자면 다음과 같다.

- boolean 타입의 필드 - boolean 접근자 메서드에서 앞 단어를 뺀 형태
- 이외에 다른 타입 - 명사나 명사구를 사용한다.

```java
// boolean 타입 필드
initialized
composite

// 이외에 다른 타입
height
digits
bodyStyle
```

# 핵심 정리

- 명명 규칙을 체화해서 자연스럽게 나오도록 하자.
- 철자 규칙은 직관적이지만 문법 규칙은 모호한 부분이 많다. 따라서 적절하게, 상식이 따르는대로 사용하자.