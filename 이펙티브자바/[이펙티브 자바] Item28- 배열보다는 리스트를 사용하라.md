# [이펙티브 자바] Item28- 배열보다는 리스트를 사용하라

배열과 제네릭 타입의 가장 큰 차이는 공변과 실체화다. 배열은 **공변**이며 **실체화가 가능**하고 제네릭은 **불공변**이며 **실체화가 불가능**하다. 

# 배열보다 리스트를 사용해야하는 첫 번째 이유

개발자라면 누구나 컴파일 타임에 오류를 발견하는 것을 선호한다. 배열은 런타임에야 오류를 발견할 수 있지만, 제네릭은 컴파일 타임에 오류를 발견할 수 있다.

아래의 설명을 통해 왜 그런지 알아보자.

### 배열은 공변?

공변은 함께 변한다는 뜻이다. 

Item28에서 말하는 배열의 공변이란 Sub가 Super의 하위 타입이라면 배열 Sub[]는 Super[]의 하위타입이라는 것을 의미한다. 더 쉽게 이해하기 위해 다음 코드를 살펴보자.

```java
// 컴파일에 이상이 없다.
Object[] objectArr = new Long[1]; // 공변
```

Long은 Obejct의 하위 타입이기 때문에 배열 Long 배열은 Object 배열의 하위 타입이다. 따라서 위의 코드는 이상없이 컴파일 된다.

반면에, 제네릭은 서로 다른 타입 Type1과 Type2가 존재할 때 List<Type1>과 List<Type2>는 하위 타입도 상위 타입도 아니다. 

```java
// 컴파일 에러
List<Object> objectList = new ArrayList<Long>(); // 불공변
```

제네릭은 불공변이므로 ArrayList<Long>은 List<Object>의 하위 타입도 상위 타입도 아니다. 따라서 컴파일 타임에 호환되지 않는 타입임을 인지하고 컴파일 에러가 발생하게 된다.

```java
Object[] objectArr = new Long[1]; // 공변
objectArr[0] = "문자열을 넣을 수 있나요?" // 런타임 에러 발생

List<Object> objectList = new ArrayList<Long>(); // 컴파일 에러 발생
```

이게 **배열보다 리스트를 사용**하라고 한 **첫 번째 이유**이다. 

# 배열보다 리스트를 사용해야하는 두 번째 이유

### 실체화 가능 타입과 실체화 불가능 타입