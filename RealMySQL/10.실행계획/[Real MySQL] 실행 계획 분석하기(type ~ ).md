# [Real MySQL 8.0] 실행 계획 분석하기(type ~ )

## type 컬럼

쿼리의 실행 계획에서 type 이후의 컬럼은 테이블 레코드를 어떤 방식으로 읽었는지를 나타낸다. 일반적으로 **쿼리 튜닝에서 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하므로 type 컬럼은 반드시 체크해야 하는 중요한 정보다.**

아래의 12개 접근 방법은 type 컬럼에 표시될 수 있는 값들 중 성능이 빠른 순서대로 나열한 것이다.

- system
- const
- eq_ref
- ref
- fulltext
- ref_or_null
- unique_subquery
- index_subquery
- range
- index_merge
- index
- ALL

마지막 ALL을 뺀 나머지는 모두 index를 사용한 접근 방법이며, index_merge를 제외한 나머지 접근 방법은 하나의 인덱스만 사용한다. 따라서 **type 컬럼에도 라인 별로 하나의 인덱스 이름만 표시된다.**

### system

레코드가 1건만 존재하는 테이블 또는 한 건도 존재하지 않는 테이블을 참조하는 형태의 접근 방법이다. InnoDB 스토리지 엔진에서는 나타나지 않고 MyISAM이나 MEMORY에서만 사용되는 접근 방법이다.

### const

테이블 레코드 건수와 관계없이 **쿼리가 프라이머리 키나 유니크 키 컬럼을 이용하는 where 조건절을 가지고있으며, 반드시 1건을 반환하는 쿼리의 처리 방식**을 const라고 한다.

```sql
EXPLAIN
SELECT * FROM employees WHERE emp_no = 10001;

+------+------------+------------+------+---------+---------+
|id    |select_type | table      | type | key     | key_len |
+------+------------+------------+------+---------+---------+
| 1    |SIMPLE      | employees  | const| PRIMARY |       4 |
+------+------------+------------+------+---------+---------+
```

이러한 방식을 다른 DBMS에서는 **유니크 인덱스 스캔**이라고 표현한다.

```sql
EXPLAIN
SELECT * FROM dept_emp WHERE dept_no='d005' ;

+------+------------+------------+------+---------+---------+
|id    |select_type | table      | type | key     | rows    |
+------+------------+------------+------+---------+---------+
| 1    |SIMPLE      | dept_emp   | ref  | PRIMARY | 165571  |
+------+------------+------------+------+---------+---------+
```

다중 컬럼으로 구성된 프라이머리 키나 유니크 키 중에서 인덱스의 일부 컬럼만 조건으로 사용할 때는 const 타입의 접근 방법을 사용할 수 없다. MySQL 엔진이 데이터를 읽어보지 않고서는 레코드가 1건이라는 것을 확신할 수 없기 때문이다. 따라서 프라이머리 키의 일부만 조건으로 사용할 때는 type 컬럼에 ref로 표시된다.

하지만 다음과 같이 **프라이머리 키나 유니크 인덱스의 모든 컬럼을 동등 조건으로 WEHRE 절에 명시하면 const 접근 방법을 사용**한다.

```sql
EXPLAIN
SELECT * FROM dept_emp WHERE dept_no='d005' and emp_no=10001;

+------+------------+------------+------+---------+---------+------+
|id    |select_type | table      | type | key     | key_len | rows |
+------+------------+------------+------+---------+---------+------+
| 1    |SIMPLE      | dept_emp   | const| PRIMARY | 20      |    1 |
+------+------------+------------+------+---------+---------+------+
```

실행 계획의 type 컬럼이 const(상수)로 표시되는 이유는 MySQL의 옵티마이저가 쿼리를 최적화하는 단계에서 쿼리를 먼저 실행해 통째로 상수화 하기 때문이다.

### eq_ref

eq_ref 접근 방법은 여러 테이블이 조인되는 쿼리의 실행 계획에서만 표시된다.
**드라이빙 테이블의 컬럼 값을 드리븐 테이블의 프라이머리 키나 유니크 키 컬럼의 검색 조건에 사용할 때를 가리켜 eq_ref라고 한다.** 이때 두 번째 이후에 읽는 테이블의 type 컬럼에 eq_ref가 표시된다.

- eq_ref 접근 방법의 제약 조건
    - 두 번째 이후에 읽히는 테이블을 유니크 키로 검색할 때, 그 유니크 인덱스는 NOT NULL이어야 한다.
    - 다중 컬럼으로 만들어진 PK나 유니크 인덱스라면 인덱스의 모든 컬럼이 비교 조건에 사용돼야만 eq_ref 접근 방법이 사용될 수 있다.
    - 두 번째 이후에 읽는 테이블에서 반드시 1건의 레코드만 반환한다는 보장이 있어야 한다.

이해를 돕기위해 다음 예제를 살펴보자.

```sql
EXPLAIN
SELECT * FROM dept_emp de, employees e
WHERE e.emp_no=de.emp_no AND de.dept_no='d005';

+------+------------+-------+-------+---------+---------+--------+
|id    |select_type | table | type  | key     | key_len | rows   |
+------+------------+-------+-------+---------+---------+--------+
| 1    |SIMPLE      | de    | ref   | PRIMARY | 16      | 165571 |
| 1    |SIMPLE      | e     | eq_ref| PRIMARY | 4       |      1 |
+------+------------+-------+-------+---------+---------+--------+
```

id 값이 같은 것을 보아 조인으로 실행된다는 것을 알 수 있고, 실행 계획에서 de 테이블이 위쪽에 있으므로 드라이빙 테이블이 된다는 것을 알 수 있다. 이는 dept_emp 테이블을 먼저 읽고 `e.emp_no = de.emp_no` 조건을 이용해 employees 테이블을 검색한다는 것을 나타낸다. 이때, emp_no는 employees 테이블의 PK이므로 두 번째 라인에서 eq_ref가 표시된 것을 확인할 수 있다.

### ref

eq_ref와는 다르게 조인의 순서와 관계없이 사용되며, PK나 유니크 키 등의 제약 조건이 없다. 인덱스의 종류와 관계없이 동등 조건으로 검색할 때는 ref 접근 방법이 사용된다.

반환되는 레코드가 반드시 1건이라는 보장이 없으므로 const나 eq_ref보다는 느리지만, 동등 조건으로만 비교되므로 매우 빠른 레코드 조회 방법 중 하나다.

```sql
EXPLAIN
SELECT * FROM dept_emp WHERE dept_no='d005' ;

+------+------------+----------+-----+---------+---------+-------+
|id    |select_type | table    | type| key     | key_len | ref   |
+------+------------+----------+-----+---------+---------+-------+
| 1    |SIMPLE      | dept_emp | ref | PRIMARY | 16      | const |
+------+------------+----------+-----+---------+---------+-------+
```

위 예제에서는 dept_emp의 PK를 구성하는 컬럼(dept_no, emp_no)의 일부만 동등 조건으로 사용됐기 때문에 일치 레코드가 1건이라는 보장이 없다. 따라서 const가 아닌 ref 접근 방법이 사용되었다.

지금까지 살펴본 실행 계획의 type에 대해 다시 한번 정리해보면 다음과 같다.

- const
    - 조인 순서에 상관없이 PK나 유니크 키의 모든 컬럼에 대해 동등 조건으로 검색(1건의 레코드만 반환)
- eq_ref
    - 드라이빙 테이블의 컬럼 값을 이용해 드리븐 테이블의 PK나 유니크 키로 동등 조건 검색(1건의 레코드만 반환)
- ref
    - 조인 순서와 인덱스의 종류에 상관없이 동등 조건으로 검색(1건의 레코드만 반환된다는 보장이 없어도 됨)

이 세 가지 접근 방법 모두 WHERE 조건절에 **동등 비교 연산자(=, <=>)**를 사용해야 한다는 공통점이 있다. 또한, 세 가지 모두 매우 좋은 접근 방법으로 성능상의 문제를 일으키지 않는 접근 방법이다.

### fulltext

MySQL 서버의 전문 검색 인덱스를 사용해 레코드를 읽는 접근 방법을 의미한다.
전문 검색은 `MACTH (…) AGAINST (…)` 구문을 사용해 실행하는데, 이때 반드시 전문 검색용 인덱스가 준비돼 있어야 한다. 테이블에 전문 검색 인덱스가 없다면 쿼리는 오류가 발생하고 중지된다.

### ref_or_null

ref 접근 방법과 같지만, NULL 비교가 추가된 형태다. ref 접근 방법 또는 NULL 비교(IS NULL) 접근 방법을 의미한다.

```sql
EXPLAIN
SELECT * FROM titles
WHERE to_date='1985-03-01' OR to_date IS NULL;
```

### unique_subquery

WHERE 조건절에서 사용될 수 있는 IN(subquery) 형태의 쿼리를 위한 접근 방법이다.
의미 그대로 서브쿼리에서 중복되지 않는 유니크한 값만 반환할 때 이 접근 방법을 사용한다.

```sql
EXPLAIN
SELECT * FROM departments
WHERE dept_no IN (SELECT dept_no FROM dept_emp WHERE emp_no=10001) ;
```

### index_subquery