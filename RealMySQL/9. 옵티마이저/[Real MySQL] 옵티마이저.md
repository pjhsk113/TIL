# [Real MySQL 8.0] 옵티마이저

요청된 쿼리는 같은 결과를 반환하지만, 내부적으로 그 결과를 어떻게 만들어낼 것인지에 대한 방법은 매우 다양하다. 따라서 어떤 방법이 최적이고 최소의 비용이 소모되는지 결정해야 한다.

MySQL에서는 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조해 최적의 **실행 계획**을 수립한다. 대부분의 DBMS에서도 옵티마이저가 이러한 기능을 담당하고 있다.

## 쿼리 실행 절차

쿼리가 실행되는 과정은 크게 세 단계로 나눌 수 있다.

1. 요청된 SQL 문장을 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)
  - SQL 파싱 단계로 SQL 파서 모듈로 처리
  - SQL 문법 오류(Syntax Error)가 이 단계에서 걸러짐
  - SQL 파스 트리 생성
2. SQL의 파싱 정보(파스 트리)를 확인해 어떤 테이블을 읽을지, 어떤 인덱스를 이용할지 결정
  - 불필요한 조건 제거 및 복잡한 연산 단순화
  - 테이블 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
  - 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
  - 임시 테이블 사용 여부 결정
  - 최적화 및 실행 계획 수립 단계로 위 과정들이 완료되면 실행 계획이 수립됌
3. 결정된 테이블의 읽기 순서나 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져옴
  - 2번에서 만들어진 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청
  - 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업 수행

## 옵티마이저 종류

- 비용 기반 최적화
  - 쿼리를 처리하기 위한 여러 방법을 만들고, 각 단위 작업의 비용과 예측된 통계 정보를 이용해 실행 계획별 비용을 산출
  - 최소 비용 처리 방법을 선택해 쿼리를 실행
  - 현재 대부분의 DBMS가 해당 최적화 방법을 사용중이다.

- 규칙 기반 최적화
  - 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립
  - 같은 쿼리에서는 항상 같은 실행 방법을 선택하는 단점이 존재한다.
  - 예전 초기 버전으로 최근에는 거의 사용되지 않는다.

## 기본 데이터 처리

RDBMS는 데이터를 정렬하거나 그루핑하는 기본 데이터 가공 기능을 가지고 있다.
MySQL 서버가 어떤 알고리즘을 이용해 이러한 기본 데이터 가공을 처리하는지 알아보자.

### 풀 테이블 스캔과 풀 인덱스 스캔

풀 테이블 스캔은 말 그대로 테이블의 데이터를 처음부터 끝까지 읽어 처리하는 작업을 의미한다. MySQL 옵티마이저는 다음과 같은 조건일 때 주로 풀 테이블 스캔을 선택한다.

- 테이블 레코드 건수가 너무 작은 경우(테이브블 페이지 1개로 구성된 경우)
- WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스가 있더라도 조건 일치 레코드 건수가 너무 많은 경우

대부분의 DBMS는 풀 테이블 스캔 시 한꺼번에 여러 개의 블록이나 페이지를 읽어오는 기능을 내장하고 있다. InnoDB 스토리지 엔진의 경우 **백그라운드 스레드에 의해 시작되는 리드 어헤드 작업**에 의해 이러한 기능이 지원된다.

**리드 어헤드(Read ahead)란** **어떤 영역의 데이터가 앞으로 필요해질 것을 예측해서 미리 디스크로부터 읽어 InnoDB 버퍼풀에 담아두는 것을 의미한다.**

풀 테이블 스캔이 일어나면 **포그라운드 스레드가 페이지 읽기를 실행**하고 **특정 시점부터는 해당 읽기 작업을 백그라운드 스레드로 넘긴다**. 백그라운드 스레드로 넘겨받는 시점부터 한 번에 최대 64개의 데이터 페이지까지 읽어 버퍼풀에 저장해둔다. 이렇게 하면 포그라운드 스레드는 버퍼풀에 미리 준비된 데이터를 가져다 사용하면되므로 쿼리를 빠르게 처리할 수 있게 되는것이다.

- 풀 인덱스 스캔은 인덱스 살펴보기 2/2를 참조

### 병렬 처리

MySQL 8.0부터는 용도가 한정돼 있긴 하지만 하나의 쿼리를 여러 스레드가 나누어 동시에 처리할 수 있는 병렬 처리가 가능해졌다.

innodb_parallel_read_threads라는 시스템 변수를 이용해 **아무런 WHERE 조건 없이 단순히 테이블 전체 건수를 가져오는 쿼리만 병렬로 처리할 수 있다.**

```sql
-- 4개의 스레드를 사용해 쿼리를 병렬 처리
SET SESSION innodb_parallel_read_threads=4;
SELECT COUNT(*) FROM salaries;
```

병렬 처리용 스레드 수가 늘어날 수록 쿼리 처리 속도가 빨라지는걸 화인할 수 있지만, 서버에 장착된 CPU 코어 개수를 넘어서면 오히려 성능이 떨어질 수 있으니 주의하자.

### ORDER BY 처리(Using filesort)