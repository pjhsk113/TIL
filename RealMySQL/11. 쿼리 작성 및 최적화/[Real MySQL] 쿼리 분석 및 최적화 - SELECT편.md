# [Real MySQL 8.0] 쿼리 작성 및 최적화 - SELECT 편

## SELECT 절의 처리 순서

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f0f41e8d-0c0a-4429-ab89-7ddd6e82658f/Untitled.png)

위 순서가 바뀌어서 실행되는 형태의 쿼리는 거의 없다.
쿼리에서 어느 절이 먼저 실행되는지 모르면 처리 내용이나 처리 결과를 예측할 수 없으므로 잘 알아두자.

다만, 실행 순서를 벗어나는 쿼리가 필요하다면 서브쿼리로 작성된 **인라인 뷰**를 사용하면 된다.

> 인라인 뷰(Inline View)란?
하나의 질의문 내에서만 생성되어 사용 되어지고 질의문 수행 종료 후에는 사라지는 뷰를 뜻한다.
일반적으로 FROM 절에서 서브쿼리를 하나의 테이블로 사용하는 형태를 말한다.
>

하지만 인라인 뷰가 사용되면 임시 테이블이 사용되기 때문에 주의해야 한다.

## 인덱스를 사용하기 위한 기본 규칙

### 인덱스 컬럼 변형 없이 사용하기

WHERE 절이나 ORDER BY, GROUP BY가 인덱스를 사용하려면 값에 대한 변형없이 인덱스 컬럼을 그대로 사용해야 한다.

```sql
SELECT * FROM salaries WHERE salary * 10 > 150000;
```

위와 같은 쿼리는 salary 인덱스가 있더라도 값을 변형해서 비교하므로 인덱스를 이용할 수 없다.

### 비교 대상의 데이터 타입 일치

WHERE 절에 사용되는 비교 조건에서 연산자 양쪽의 비교 대상 값은 데이터 타입이 일치해야 한다.

```sql
SELECT * FROM tb_test WHERE age=2;
```

위 쿼리의 age 컬럼은 문자열 타입으로 선언되었지만 비교 연산에는 숫자 타입으로 비교된다. 따라서 ref나 range가 아닌 index(인덱스 풀 스캔)이 사용된다.

이 경우 MySQL 옵티마이저가 내부적으로 문자열 타입을 숫자 타입으로 변환한 후 비교 작업을 처리하는데, 타입이 변환된 후 비교 작업을 처리해야 하므로 인덱스 레인지 스캔이 불가능한 것이다.

따라서 SQL을 작성할 때는 반드시 데이터 타입을 맞춰 비교 조건을 사용하자.

## WHERE 절의 인덱스 사용

WHERE 절의 인덱스 사용 방법은 **작업 범위 결정 조건**과 **체크 조건** 두 가지 방식으로 구분한다.