# 4-2 InnoDB 스토리지 엔진 아키텍처

## InnoDB 스토리지 엔진

MySQL의 스토리지 엔진 중에서 유일하게 레코드 기반의 잠금을 제공하며, 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어난 스토리지 엔진이다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/542f4ab3-514e-4e55-ba8a-fd126a7f79ca/Untitled.png)

### 프라이머리 키에 의한 클러스터링

- InnoDB의 모든 테이블은 프라이머리 키 값의 순서대로 디스크에 저장된다.
- 모든 세컨더리 인덱스는 레코드 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.
- 프라이머리 키는 클러스터링 인덱스이기 때문에 프라이머리 키를 이용한 레인지 스캔은 상당히 빨리 처리될 수 있다.
- 결과 적으로 쿼리의 실행 계획에서 다른 보조 인덱스보다 프라이머리 키가 인덱스로 선택될 확률이 높다.

### 외래키 지원

- InnoDB 스토리지 엔진 레벨에서만 지원한다. MyISAM이나 MEMORY 테이블에서는 사용할 수 없다.
- 외래키는 실제 서비스 운영 환경에 사용하지 않는 경우가 있다. 그 이유는 부모와 자식 테이블에 인덱스 생성이 필요하고, 변경시 잠금이 여러 테이블로 전파되어 데드락이 발생할 확률이 높아지기 때문이다.
- foreign_key_checks 시스템 변수를 OFF로 설정하여 외래키 관계 체크 작업을 일시적으로 멈출 수 있다.
- foreign_key_checks 시스템 변수를 OFF한 경우 데이터 일관성에 문제가 생길 수 있으므로 반드시 부모와 자식 테이블 간 일관성을 맞춘 후 다시 활성화 해야한다.

### MVCC(Multi Version Concurrency Control)

MVCC의 가장 큰 목적은 **잠금을 사용하지 않는 일관된 읽기**를 제공하는데 있다. InnoDB 스토리지 엔진은 언두 로그를 이용해 MVCC 기능을 구현했다.

MVCC는 하나의 레코드에 대해 여러 버전이 동시에 관리되는 것을 뜻하며 격리 수준(isolation level)에 따라 처리되는 방식이 다르다.

READ_UNCOMMITTED의 경우 InnoDB 버퍼 풀이나 데이터 파일로부터 데이터를 읽어 반환한다. 즉, 커밋됐든 아니든 변경된 상태의 데이터를 반환하게 된다. 그 이상의 격리 수준인 READ_COMMITTED, REPEATABLE_READ은 InooDB 버퍼 풀이나 데이터 파일 대신 변경되기 전 내용을 보관하고 있는 **언두 영역**의 데이터를 반환하며, 이러한 과정을 MVCC라고 표현한다.

### 잠금 없는 일관된 읽기

InnoDB 스토리지 엔진은 MVCC을 이용해 잠금을 걸지 않고 읽기 작업을 수행한다.
**SERIALIZABLE이 아닌 다른 격리 수준에서는 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고 읽기 작업이 가능하다.**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7f024f57-7a57-4e67-bee3-d1dcfffaf9c1/Untitled.png)

### 자동 데드락 감지

- InnoDB 스토리지 엔진은 잠금 대기 목록을 그래프 형태로 관리한다.
- 데드락 감지 스레드가 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 강제 종료한다.
    - 언두 로그의 양이 적은 트랜잭션이 먼저 종료된다.

데드락 감지 스레드가 잠금 목록을 체크할 때 잠금 목록에 새로운 잠금이 걸리므로 동시 처리 스레드가 매우 많은 경우 많은 CPU 자원 소모가 생길 수 있다. 따라서 서비스에 성능에 악영향을 줄 수 있는 상황이 생긴다.

이 문제를 해결하는 방법 중 하나는 innodb_deadlock_detect 시스템 변수를 OFF 하고 innodb_lock_wait_timeout 시스템 변수를 활성화하여 데드락 상황에서 일정 시간동안 잠금을 획득하지 못했을 경우 요청이 실패하고 에러 메시지를 반환하게 하는 방식으로 문제를 우회할 수 있다.

### 자동화된 장애 복구

InnoDB는 손실이나 장애로부터 데이터를 보호하기 위한 여러 메커니즘이 탑재되어 있다.
InnoDB 데이터 파일은 기본적으로 MySQL 서버가 시작될 때 항상 자동 복구를 수행하는데, 디스크나 서버 하드웨어 이슈로 자동 복구를 못하는 경우가 발생하면 자동 복구를 멈추고 MySQL 서버가 종료돼 버린다.

이때는 innodb_force_recovery 시스템 변수를 설정해서 MySQL 서버를 시작해야 한다.
1~6의 값을 가지며 단계 별로 선별적 자동복구를 진행할 수 있다.

- innodb_force_recovery - 1 (SRV_F0RCE_IGN0RE_C0RRUPT)
    - InnoDB의 테이블스페이스의 데이터나 인덱스 페이지에서 손상된 부분이 발견돼도 무시하고 MySQL 서버를 시작한다.
- innodb_force_recovery - 2 (SRV_F0RCE_N0_BACKGR0UND)
    - 백그라운드 스레드 가운데 메인 스레드를 시작하지 않고 MySQL 서버를 시작한다. InnoDB의 메인 스레드가 언두 데이터를 삭제하는 과정에서 장애가 발생한다면 이 모드로 복구하면 된다.
- innodb_force_recovery - 3 (SRV_F0RCE_N0_TRX_UND0)
    - 커밋되지 않고 종료된 트랜잭션은 계속 그 상태로 남아 있게 MySQL 서버를 시작 하는 모드
- innodb_force_recovery - 4 (SRV_F0RCE_N0_IBUF_MERGE)
    - InnoDB 스토리지 엔진이 인서트 버퍼의 내용을 무시하고 강제로 MySQL이 시작되게 한다.인서트 버퍼는 실제 데이터와 관련된 부분이 아니라 인덱스에 관련된 부분이므로 테이블 을 덤프한 후 다시 데이터베이스를 구축하면 데이터의 손실 없이 복구할 수 있다.
- innodb_force_recovery - 5 (SRV_F0RCE_N0_UND0_L0G_SCAN)
    - InnoDB 엔진이 언두 로그를 모두 무시하고 MySQL을 시작할 수 있다. 하지만 이 모드로 복구되면 MySQL 서버가 종료되던 시점에 커밋되지 않았던 작업도 모두 커밋된 것처럼 처리되므로 실제로는 잘못된 데이터가 데이터베이스에 남는 것이라고 볼 수 있다.
- innodb_force_recovery - 6 (SRV_F0RCE_N0_L0G_RED0)
    - InnoDB 엔진이 리두 로그를 모두 무시한 채로 MySQL 서버가 시작된다. 커밋됐다 하더라도 리두 로그에만 기록되고 데이터 파일에 기록되지 않은 데이터는 모두 무시된다. 즉, 마지막 체크포인트 시점의 데이터만 남게 된다.


## InnoDB 버퍼 풀

InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다. 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 같이 한다.

> 버퍼가 역할?
Insert, Update, Delete처럼 데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시킨다. 하지만 버퍼 풀이 이러한 변경 된 데이터를 모아서 처리하면 랜 덤한 디스크작업의 횟수를 줄일 수 있다 .
>

### 버퍼 풀의 구조

버퍼 풀이라는 메모리 공간은 페이지라는 조각으로 쪼개지고 필요로 할 때 데이터 페이지를 읽어 각 조각에 저장되는 구조를 가지고 있다.

InnoDB 스토리지 엔진은 버퍼 풀의 페이지 조각을 관리하기 위해 LRU 리스트, 플러시 리스트, 프리 리스트라는 3개의 자료 구조를 관리한다.

- LRU(Least Recently Used) 리스트
    - 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼 풀 메모리에 유지해서 디스크 읽기를 최소화
- 플러시 리스트
    - **디스크로 동기화 되지 않은 데이터 페이지(더티 페이지)**의 변경 시점 기준의 페이지 목록을 관리
- 프리 리스트
    - 데이터가 채워지지 않은 비어있는 페이지 목록으로, 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다.


### 버퍼 풀과 리두 로그