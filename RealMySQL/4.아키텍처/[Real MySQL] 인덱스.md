# [Real MySQL 8.0] 인덱스

## 인덱스란?

인덱스는 컬럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 삼아 주어진 순서로 미리 정렬해 저장해두고 원하는 결과를 최대한 빠르게 찾아갈 수 있도록 한다.

인덱스를 쉽게 설명해 책으로 비유하자면 색인으로 설명할 수 있다.
책의 **색인을 통해 알아낼 수 있는 페이지 번호**는 데이터 파일에 저장된 **레코드의 주소**에 비유될 것이고, 해당 **페이지의 내용**은 **데이터 파일**에 비유할 수 있다.

또 색인과 DBMS 인덱스의 중요한 공통점은 바로 정렬이다.
색인의 내용이 너무 많으면 원하는 검색어를 찾아내는데 시간이 걸릴 것이다.
이때 색인의 정보가 정렬이 되어있다면(ㄱ, ㄴ, ㄷ, …) 원하는 정보를 최대한 빠르게 찾아갈 수 있다. 인덱스도 마찬가지로 컬럼의 값을 주어진 순서로 미리 정렬해서 보관하므로 원하는 결과를 최대한 빠르게 찾아갈 수 있다.

### 인덱스 사용 목적

DBMS에서 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. 따라서 인덱스를 생성해놓고 이 시간을 단축시키는 것이 목적이다. 즉, 데이터의 읽기 속도를 높이는 기능으로 볼 수 있다.

읽기 속도는 향상되지만 데이터의 추가나 삭제 시 인덱스 또한 재정렬 과정을 거쳐야하므로 INSERT, UPDATE, DELETE와 같은 데이터 저장 성능은 떨어질 수 밖에 없다. 따라서 무분별한 인덱스 추가는 지양해야하며 저장 속도를 얼마나 희생할지, 읽기 속도를 얼마나 더 빠르게 만들어야 하는지에 따라 인덱스의 추가 여부를 결정해야 한다.

### 인덱스의 역할별 구분

- 프라이머리 키
    - 레코드를 대표하는 컬럼의 값으로 만들어진 인덱스를 의미한다.
    - 해당 레코드를 식별할 수 있는 값이기 때문에 식별자라고도 부른다.
    - Null을 허용하지 않으며 중복을 허용하지 않는다.
- 보조 키(세컨더리 인덱스)
    - 프라이머리 키를 제외한 나머지 모든 인덱스는 세컨더리 인덱스로 분류한다.
    - 유니크 인덱스는 프라이머리 키와 비슷하고 프라이머리 키를 대체해 사용할 수 있어 대체 키라고도 부른다.

### 인덱스의 알고리즘 별 구분

- B-Tree 인덱스
    - 가장 일반적으로 사용되는 인덱스 알고리즘으로, 오래전부터 도입된 알고리즘이기 때문에 성숙도가 높음
    - 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
    - B-Tree의 응용 버전으로 R-Tree 인덱스가 있다.
- Hash 인덱스
    - 컬럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘
    - 매우 빠른 검색을 지원한다.
    - 값을 변형해서 인덱싱하므로 prefix 일치와 같이 값의 일부만 검색하거나 범위 검색 시 Hash 인덱스를 사용할 수 없다.
    - 메모리 기반의 DB에서 많이 사용한다.

## B-Tree 인덱스

인덱싱 알고리즘 가운데 가장 일반적으로 사용되고, 가장 먼저 도입된 알고리즘으로 범용적인 목적으로 사용되는 인덱스 알고리즘이다. 컬럼의 값을 변형시키지 않고 인덱스 구조체 내에서 항상 정렬된 상태로 유지된다. 일반적으로 DMBS에서는 B-Tree의 변형 알고리즘인 B+-Tree 또는 B*-Tree가 사용된다.

B-Tree 인덱스는 **Balanced-Tree를 의미한다. Binary가 아닌 것에 주의하자.**

### 구조 및 특성

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fa70be2a-fc54-4810-a612-8cb4f9a12c79/Untitled.png)

B-Tree는 트리 구조의 **최상위에 하나의 루트 노드**가 존재하고 그 **하위에 자식 노드**가 붙어있는 구조를 가지고 있다. **가장 하위의 노드를 “리프 노드(Leaf node)”**라 하고, 루트 노드도 리프 노드도 아닌 **중간의 노드를 “브랜치 노드”**라고 한다.