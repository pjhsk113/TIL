# [Real MySQL 8.0] 그 외에 다양한 인덱스

## 멀티 밸류 인덱스

전문 검색 인덱스를 제외한 모든 인덱스는 인덱스 키와 데이터 레코드가 1:1 관계를 가진다. 하지만 멀티 밸류 인덱스는 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스다.

JSON의 배열 타입의 필드에 저장된 원소들에 대한 인덱스를 지원하기 위해 MySQL 8.0 버전에서 업그레이드 됐다.

```sql
// 멀티 밸류 인덱스 생성
CREATE TABLE user (
			user_id BIGINT AUTO_INCREMENT PRIMARY KEY, 
			first_name VARCHAR(10),
			last_name VARCHAR(10),
			credit_info JSON,
			INDEX mx_creditscores (
				(CAST(credit_info->'$.credit_scores' AS UNSIGNED ARRAY))
			)
);

// INSERT
INSERT INTO user VALUES (1, 'Matt', 'Lee1', '{"credit.scores":[360, 353, 351]}');
```

위와 같은 멀티 밸류 인덱스를 활용하려면 반드시 다음 함수들을 활용해서 검색해야만 옵티마이저가 실행 계획을 수립할 수 있다.

- MEMBER OF()
- JSON_CONTAINS()
- JSON_OVERLAPS()

```sql
SELECT * FROM user WHERE 360 MEMBER OF(credit.info->'$.credit_scores');

+----------+------------+----------+--------------------------------------+
| user_id  | first_name |last_name | credit_info                          |
+----------+------------+----------+--------------------------------------+
|       1  | Matt       | Lee      | {"credit_scores": [360, 353, 351]}   |
+----------+------------+----------+--------------------------------------+
```

## 클러스터링 인덱스

**프라이머리 키 값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스**라고 표현한다. 이는 테이블의 프라이머리 키에 대해서만 적용되는 내용이며 InnoDB 스토리지 엔진에서만 지원한다.

여기서 중요한 점은 프라이머리 키 값에 의해 레코드의 저장 위치가 결정된다는 것이다. 이 말은 프라이머리 키 값이 변경되면 물리적인 저장 위치도 변경되어야 한다는 것을 나타낸다. 따라서 클러스터링된 테이블은 프라이머리 키 값 자체에 대한 의존도가 상당히 크기 때문에 신중히 프라이머리 키를 결정해야 한다.

**클러스터링 인덱스는 알고리즘이라기 보다 테이블 레코드 저장 방식으로 볼 수 있다. 그래서 클러스터링 인덱스와 클러스터링 테이블은 동의어로 사용되기도 한다.**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b50e96d8-893d-4681-8ddb-74c6e3f8f3b3/Untitled.png)

클러스터링 인덱스(테이블)의 구조

### 세컨더리 인덱스에 미치는 영향

InnoDB 테이블의 모든 세컨더리 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키 값을 저장하도록 구현돼 있다. 만약 세컨더리 인덱스가 프라이머리 키 값이 아닌 실제 레코드 주소를 가지고 있었다면 클러스터링 키 값이 변경될 때마다 레코드의 주소가 변경되고, 해당 테이블의 모든 인덱스에 저장된 주솟값을 변경해야하는 오버헤드가 발생했을 것이기 때문이다.

employees 테이블에서 first_name 칼럼으로 검색하는 경우 프라이머리 키로 클러스터링된 InnoDB 동작 예시를 살펴보자.

```sql
CREATE TABLE employees ( 
	emp_no INT NOT NULL,
	first_name VARCHAR(20) NOT NULL, 
	PRIMARY KEY (emp_no),
	INDEX ix_firstname (first_name)
);

mysql) SELECT * FROM employees WHERE first_name='Aamer';
```

1. ix_firstname 인덱스를 검색
2. 레코드의 프라이머리 키 값을 확인
3. 확인한 프라이머리 키 인덱스를 검색해 최종 레코드를 가져옴

InnoDB는 MyISAM 처럼 실제 레코드 주소를 확인하는 것이 아니라 레코드의 프라이머리 키 값을 확인하고 그 프라이머리 키 값의 인덱스를 검색해 레코드를 가져온다.

MyISAM에 비해 조금 더 복잡하게 처리되지만, 프라이머리 키(클러스터링 인덱스)는 더 큰 장점을 제공하기 때문에 성능 저하에 대해 너무 걱정할 필요가 없다.

### 클러스터링 인덱스의 장점과 단점

- 장점
    - 프라이머리 키(클러스터링 인덱스)로 검색할 때 처리 성능이 매우 빠르다.
        - 특히, 프라이머리 키를 범위 검색하는 경우 매우 빠름
    - 테이블의 모든 세컨더리 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많다.(커버링 인덱스)
- 단점
    - 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커진다.
    - 세컨더리 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야 하므로 처리 성능이 느리다.
    - INSERT할 때 프라이머리 키에 의해 레코드 위치가 결정되므로 처리 성능이 느리다.
    - 프라이머리 키를 변경할 때 레코드를 DELETE하고 INSERT하는 작업이 필요하기 때문에 성능이 느리다.


클러스터링 인덱스의 장점과 단점을 요약해보면 **장점은 빠른 읽기(SELECT)**이며 **단점은 느린 쓰기(INSERT, UPDATE, DELETE)**라고 볼 수 있다. 일반적인 웹 서비스는 읽기가 80% ~ 90%를 차지하므로 느린 쓰기를 감수하고 빠른 읽기를 유지하는 것이 중요하다. 따라서 클러스터링 인덱스는 합리적인 선택이라고 볼 수 있다.

### 클러스터링 테이블 사용시 주의사항