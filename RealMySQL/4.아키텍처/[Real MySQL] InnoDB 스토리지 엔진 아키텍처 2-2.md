# [Real MySQL] InnoDB 스토리지 엔진 아키텍처 2/2

## 언두 로그

언두 로그란 트랜잭션과 격리 수준을 보장하기 위해 DML(INSERT, UPDATE, DELETE)로 변경되기 이전 버전의 데이터를 별도로 백업해둔 데이터를 말한다. 언두 로그의 데이터는 크게 트랜잭션의 롤백 대비용 데이터와 격리 수준을 유지하면서 높은 동시성을 제공하기 위한 용도로 사용된다.

- 트랜잭션 보장
  - 트랜잭션이 롤백되면 **언두 로그에 백업해둔 이전 버전의 데이터를 이용해 복구**한다.
- 격리 수준 보장
  - 데이터를 변경하는 도중 다른 커넥션에서 데이터를 조회하면 **격리 수준에 맞게(READ_COMMITED, REPEATABLE READ) 언두 로그에 백업해둔 데이터를 읽어서 반환**한다.

언두 로그는 InnoDB 스토리지 엔진에서 매우 중요한 역할을 담당하지만 그만큼의 관리 비용도 많이 필요하다.

### 언두 로그 레코드 모니터링

서비스 중인 MySQL 서버에서 활성 상태의 트랜잭션이 장시간 유지되는 것은 성능상 좋지 않다.

예를 들어, 트랜잭션을 시작한 상태에서 완료하지 않고 하루 정도 방치했다고 가정해보자.
이 경우 트랜잭션이 시작된 시점부터 생성된 언두 로그는 계속 InnoDB 스토리지 엔진에 보존될 것이며, 결국 하루치 데이터 변경을 모두 저장하고 디스크의 언두 로그 저장 공간은 계속 증가하게 된다.

빈번히 변경된 레코드를 조회하는 쿼리가 실행되면 InnoDB 스토리지 엔진은 언두 로그의 이력을 필요한 만큼 스캔해야만 레코드를 찾을 수 있다. 따라서 쿼리의 성능이 전반적으로 떨어지게 되는 결과를 얻게 된다.

MySQL 5.5 버전까지는 한 번 증가한 언두 로그 공간은 다시 줄어들지 않는 문제도 있었지만, 이 문제는 MySQL 5.7과 MySQL 8.0으로 업그레이드 되면서 완전히 해결되었다.

하지만 장시간 트랜잭션이 유지되는 것은 성능상 좋지 않은건 마찬가지이므로 MySQL 서버의 언두 로그 레코드가 얼마나 되는지는 항상 모니터링 하는 것이 좋다.

```sql
- // MySQL 서버의 모든 버전에서 사용 가능한 명령
SHOW ENGINE INNODB STATUS \G

- // MySQL 8.0 버전에서 사용 가능한 명령
SELECT count
FROM information_schema.innodb_metrics
WHERE SUBSYSTEM='transaction' AND NAME='trx_rseg_history_len';
```

### 언두 테이블스페이스 관리

언두 로그가 저장되는 공간을 언두 테이블스페이스라고 하는데, 이 공간은 서버가 초기화될 때 생성되기 때문에 확장에 한계가 있었다. 따라서 언두 테이블스페이스는 MySQL 버전별로 많은 변화가 있었다.

- MySQL 5.6 이전 버전
  - 언두 로그가 모두 테이블스페이스에 저장
- MySQL 5.6 버전
  - innodb_undo_tablesapces 시스템 변수 도입
  - innodb_undo_tablesapces 시스템 변수 값을 0으로 설정한 경우 언두 로그를 시스템 테이블스페이스에 저장
  - innodb_undo_tablesapces 시스템 변수 값을 2보다 큰 값으로 설정한 경우 별도의 언두 로그 파일에 저장
- MySQL 8.0
  - innodb_undo_tablesapces 시스템 변수 Deprecated
  - 언두 로그를 항상 외부의 별도 로그 파일에 기록


하나의 언두 테이블스페이스는 1개 이상 128개 이하의 롤백 세그먼트를 가지며, 롤백 세그먼트는 1개 이상의 언두 슬롯을 가진다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/51290472-6202-4ff6-b4cf-9c6be2d27ad7/Untitled.png)

하나의 트랜잭션이 필요로 하는 언두 슬롯의 개수는 DML의 특성에 따라 최대 4개까지 사용하게 된다. 우리는 다음과 같은 수식으로 최대 동시 처리 가능 트랜잭션 개수를 예측해 볼 수 있다.

`최대 동시 트랜잭션 수 = (InnoDB 페이지 크기) / 16 * (롤백 세그먼트 개수) ******* (언두 테이블스페이
스 개수)`

언두 로그 공간이 남는 것은 문제가 되지 않지만, 언두 로그 슬롯이 부족한 경우 트랜잭션을 시작할 수 없는 심각한 문제가 발생한다. MySQL 8.0 이전에는 한 번 생성된 언두 로그는 변경이 허용되지 않고 정적으로 사용되었지만 MySQL 8.0 버전부터는 CREATE UNDO TABLESPACE나 DROP TABLESPACE 같은 명령으로 언두 테이블스페이스를 동적으로 추가하고 삭제할 수 있게 개선되었다.

## 체인지 버퍼

체인지 버퍼는 변경해야 할 인덱스 페이지를 디스크로부터 읽어와야하는 경우 자원 소모를 줄이기 위해 사용되는 임시 메모리 공간을 뜻한다.

레코드가 INSERT 혹은 UPDATE 될 때데이터 파일을 변경하는 작업뿐 아니라 **해당 테이블에 포함된 인덱스도 업데이트하는 작업이 필요**하다. 그런데 테이블에 인덱스가 많다면 이 작업은 디스크를 랜덤하게 읽는 작업이 필요하다. InnoDB는 변경해야할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만, 그렇지 않은 경우 디스크로부터 읽어와야하기 때문이다. 따라서 이러한 작업은 **상당히 많은 자원을 소모**하게 된다.

이러한 자원 소모를 막기위해 InnoDB는 즉시 업데이트를 실행하지 않고 인덱스 레코드를 체인지 버퍼에 저장해두었다가 사용자에게 결과를 반환하는 형태로 성능을 향상 시킨다.

이후 체인지 버퍼에 임시로 저장된 인덱스 레코드 조각은 버퍼 머지 스레드라는 백그라운드 스레드에 의해 병합된다.

MySQL 5.5 이전 버전까지는 INSERT 작업에 대해서만 이러한 버퍼링 기능(인서트 버퍼)을 사용할 수 있었지만, MySQL 5.5 버전부터 조금씩 개선되며 MySQL 8.0 버전부터는 INSERT, UPDATE, DELETE로 인해 키를 추가하거나 삭제하는 작업에 대해서도 버퍼링이 될 수 있게 개선되었다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fd4fe6ee-7b57-4738-9b9d-097d169550b1/Untitled.png)

## 리두 로그 및 로그 버퍼

리두 로그는 트랜잭션의 4가지 요소인 ACID(원자성, 일관성, 격리성, 지속성)중 D에 해당하는 영속성과 가장 밀접하게 연간돼 있으며, 하드웨어나 소프트웨어 등 여러 가지 문제점으로 인해 MySQL 서버가 비정상적으로 종료되었을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치 역할을 한다.